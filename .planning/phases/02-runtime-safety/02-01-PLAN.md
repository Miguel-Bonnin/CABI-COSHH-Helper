---
phase: 02-runtime-safety
plan: 01
type: tdd
depends_on: []
files_modified: [js/modules/riskCalculator.js, tests/riskCalculator.test.js]
---

<objective>
Add input validation to risk calculator functions to prevent runtime errors from invalid data.

Purpose: Ensure risk calculations fail gracefully with clear errors instead of producing incorrect results or crashing when given invalid inputs (null, undefined, wrong types, out-of-range values).
Output: Validated risk calculation functions with comprehensive edge case handling and 100% test coverage.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-testing-foundation/01-02-SUMMARY.md
@.planning/phases/01-testing-foundation/01-03-SUMMARY.md
@js/modules/riskCalculator.js
@tests/riskCalculator.test.js

**Tech stack available:**
- Vitest test framework with happy-dom
- ES6 modules ("type": "module")
- Pure function design pattern established

**Established patterns:**
- TDD workflow: RED → GREEN → REFACTOR
- Helper function extraction for clarity
- Comprehensive test coverage with edge cases
- Tests directory at root level

**Constraining decisions:**
- Pure functions with no DOM dependencies (from Phase 1)
- Named exports for tree-shaking (from Phase 1)
- Input validation should throw descriptive errors (not silent failures)
</context>

<feature>
  <name>Input validation for risk calculator functions</name>
  <files>js/modules/riskCalculator.js, tests/riskCalculator.test.js</files>
  <behavior>
**calculateOverallSeverity(hPhrases, signalWord)**
- Invalid hPhrases (null/undefined/non-array) → throw TypeError
- Invalid signalWord (null/undefined/non-string) → throw TypeError
- Empty array is valid → returns signal word severity
- Empty string signalWord is valid → returns 1

**calculateOverallLikelihood(procedureData, quantity, unit, frequency, duration)**
- Invalid quantity (null/undefined/non-number/negative) → throw TypeError/RangeError
- Invalid unit (null/undefined/non-string/unrecognized) → throw TypeError
- Invalid frequency (null/undefined/non-string) → throw TypeError (unrecognized values default to 0)
- Invalid duration (null/undefined/non-string) → throw TypeError (unrecognized values default to 0)
- null procedureData is valid → uses default base score of 1.5
- Zero quantity is valid → returns minimum likelihood

**Test cases:**
1. Severity: null hPhrases → throws TypeError
2. Severity: undefined hPhrases → throws TypeError
3. Severity: non-array hPhrases → throws TypeError
4. Severity: null signalWord → throws TypeError
5. Severity: undefined signalWord → throws TypeError
6. Severity: non-string signalWord → throws TypeError
7. Likelihood: null quantity → throws TypeError
8. Likelihood: undefined quantity → throws TypeError
9. Likelihood: negative quantity → throws RangeError
10. Likelihood: non-number quantity → throws TypeError
11. Likelihood: null unit → throws TypeError
12. Likelihood: undefined unit → throws TypeError
13. Likelihood: invalid unit string → throws TypeError (not in allowed list)
14. Likelihood: null frequency → throws TypeError
15. Likelihood: undefined frequency → throws TypeError
16. Likelihood: null duration → throws TypeError
17. Likelihood: undefined duration → throws TypeError
18. All validation errors have clear messages indicating parameter name and issue
  </behavior>
  <implementation>
**Validation approach:**
- Add validation at start of each exported function (guard clauses)
- Use explicit type checks: `typeof`, `Array.isArray()`, `isNaN()`
- Throw appropriate error types: TypeError for wrong types, RangeError for out-of-bounds values
- Error messages format: "{functionName}: {parameterName} must be {expectation}, got {actual}"
- Valid unit list: ['µg', 'mg', 'g', 'kg', 'µL', 'mL', 'L']
- After validation, existing logic remains unchanged

**Don't:**
- Don't use loose equality (==) for type checks - use strict (===)
- Don't silently coerce types - throw errors instead
- Don't validate helper function inputs (private functions, already validated by public function)
- Don't add validation to procedureData properties (null procedureData is valid, structure varies)
  </implementation>
</feature>

<verification>
npm test -- riskCalculator
- All existing 25 tests still pass
- All new validation tests pass
- 100% coverage of validation branches
</verification>

<success_criteria>
- Failing validation tests written and committed (RED)
- Implementation passes all tests (GREEN)
- Refactoring complete if beneficial (REFACTOR)
- All 2-3 commits present with TDD commit pattern
- Error messages are clear and actionable
- No breaking changes to existing functionality
</success_criteria>

<output>
After completion, create `.planning/phases/02-runtime-safety/02-01-SUMMARY.md`:

# Phase 2 Plan 1: Risk Calculator Validation Summary

**[One-line accomplishment summary]**

## Accomplishments

- **RED**: [What validation tests were written, how many]
- **GREEN**: [What validation was implemented, error types used]
- **REFACTOR**: [What cleanup was done, or "None needed"]

## Files Created/Modified

- `js/modules/riskCalculator.js` - [Description of validation added]
- `tests/riskCalculator.test.js` - [Number of validation tests added]

## Commits

1. **RED**: test(02-01): [commit message]
2. **GREEN**: feat(02-01): [commit message]
3. **REFACTOR** (if applicable): refactor(02-01): [commit message]

## Decisions Made

[Key decisions about validation approach, error types, edge case handling]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for [02-02-PLAN.md] - Data Loading Error Handling
</output>
